// The exploit-2 program enables vesting (progressively release total amount to the final recipient).
// The init_vesting instruction takes as parameters the total amount to be vested,
// the start and end times, when the vesting should be active and an interval how often a
// new partial amount will be released to the recipient. The recipient can withdraw
// currently unlocked funds in multiple transactions or the complete amount once the vesting has expired.

// TASK: Modify the vesting program input parameters and find bugs in the program.
//       There are multiple issues in the calculation of the unlocked amount. To finish this task, find a
//       bug that will not allow the recipient to withdraw the total vested amount even after the vesting has expired.
//    -> Verify if you were successful by runnig `anchor run exploit2` from the terminal.

import * as anchor from "@coral-xyz/anchor";
import * as web3 from "@solana/web3.js";
import { assert } from "chai";
import { Exploit2 } from "../../target/types/exploit_2";

describe("Exploit 2", async () => {
  let provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);
  let exploitSuccessful = false;

  const program = anchor.workspace.Exploit2 as anchor.Program<Exploit2>;
  const sender = web3.Keypair.generate();
  const recipient = web3.Keypair.generate();
  const escrow = web3.Keypair.generate();
  before("Fund the sender!", async () => {
    await airdrop(provider.connection, sender.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);
    await airdrop(provider.connection, recipient.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);
  });

  let now = new anchor.BN(+new Date() / 1000); // current time in seconds

  // x x x x x x x x x x x x x x x x x x x x x
  // | | | | | | | | | | | | | | | | | | | | |
  //           EDIT THE CODE BELOW
  // | | | | | | | | | | | | | | | | | | | | |
  // v v v v v v v v v v v v v v v v v v v v v


  const amount = new anchor.BN(2001000); // amount to vest
  const start = now.subn(10000); // start vesting in the past so that we do not need to wait
  const end = now; // end now so that we do not need to wait to withdraw whole vested amount
  const interval = new anchor.BN(5); // unlock new amount every X seconds


  // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
  // | | | | | | | | | | | | | | | | | | | | |
  //           EDIT THE CODE ABOVE
  // | | | | | | | | | | | | | | | | | | | | |
  // x x x x x x x x x x x x x x x x x x x x x

  it("Initialize vesting!", async () => {
    const tx = await program.methods
      .initVesting(amount, start, end, interval)
      .accounts({
        sender: sender.publicKey,
        recipient: recipient.publicKey,
        escrow: escrow.publicKey,
        systemProgram: web3.SystemProgram.programId,
      })
      .signers([sender, escrow])
      .rpc();
  });


  it("Bug evaluation", async () => {
    exploitSuccessful = false;
    let recipientBalanceBefore = await provider.connection.getBalance(recipient.publicKey, "confirmed");

    let now = new anchor.BN(+new Date() / 1000);
    let maxFutureDuration = 10;

    if (now < end) {
      if (end.sub(now).toNumber() > maxFutureDuration) {
        assert.fail(`Vesting end can be maximum of ${maxFutureDuration}s into the future!!`);
      }
      await countDown(end.sub(now).toNumber(), 1);
    }

    try {
      await program.methods.withdrawUnlocked()
        .accounts(
          {
            recipient: recipient.publicKey,
            escrow: escrow.publicKey,
          }
        )
        .signers([recipient])
        .rpc({ commitment: "confirmed" });
    }
    catch (err) {
      exploitSuccessful = true;
      return
    }
    exploitSuccessful = false;
    let recipientBalanceAfter = await provider.connection.getBalance(recipient.publicKey, "confirmed");
    assert.strictEqual(recipientBalanceAfter, recipientBalanceBefore + amount.toNumber(), "Nice! You have found a bug in the solana program, that the recipient cannot withdraw the total vested amount! Keep trying to find also another bug to solve this exercise!");
    assert.fail("You did not succeed to find the bug! Recipient was able to withdraw the whole vested amount!");
  });

  after("Evaluation", async () => {
    if (exploitSuccessful) {
      console.log('\n\n\x1b[32m', 'CONGRATULATIONS!!!\nYou succeeded to find a bug where the total calculated amount to vest to the recipient is higher than the original deposit and cannot be withdrawn!', '\x1b[0m')
    }
    else {
      console.log('\n\n\x1b[31m', 'You did not suceed to find the bug!', '\x1b[0m')
    }

  });
});


async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}

async function sleep(seconds) {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
}

async function countDown(duration, update) {
  if (duration < update) {
    await sleep(duration);
  }
  else {
    let iters = Math.ceil(duration / update);
    let elapsed = 0;
    for (let i = 0; i < iters; i++) {
      process.stdout.write("Waiting " + (duration - elapsed) + " seconds until the vesting expires...")
      await sleep(update);
      elapsed = elapsed + update;
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
    }

  }
}
