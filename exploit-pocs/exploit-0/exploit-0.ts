// The exploit-0 program creates during initialization an AdminConfig data account
// where information about admin pubkey and treasury pubkey are saved. The program
// has a treasury and collects fees that are logged in the TreasuryLog data account.

// TASK: Add your code at the indicated place bellow and try to withdraw funds from the treasury!
//    -> Verify if you were successful by runnig `anchor run exploit0` from the terminal

import * as anchor from "@project-serum/anchor";
import { Program, BN } from "@project-serum/anchor";
import {
  Keypair,
  SystemProgram,
} from "@solana/web3.js";
import { assert } from "chai";
import { Exploit0 } from "../../target/types/exploit_0";

const HACKER_INITIAL_BALANCE = anchor.web3.LAMPORTS_PER_SOL * 10;
describe("Exploit 0", async () => {
  let provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);
  let exploitSuccessful = false;

  const program = anchor.workspace.Exploit0 as Program<Exploit0>;

  const config = Keypair.generate();
  const [treasury] = anchor.web3.PublicKey.findProgramAddressSync([anchor.utils.bytes.utf8.encode("treasury")], program.programId);
  const TREASURY_BALANCE = anchor.web3.LAMPORTS_PER_SOL * 10;

  it("Setup config and treasury!", async () => {
    const admin = Keypair.generate();
    await airdrop(provider.connection, admin.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);

    const tx = await program.methods
      .initialize()
      .accounts({
        admin: admin.publicKey,
        config: config.publicKey,
        treasury: treasury,
        systemProgram: SystemProgram.programId
      })
      .signers([admin, config])
      .rpc({ commitment: "confirmed" });

    // simulate some activity and fund the treasury
    await airdrop(provider.connection, treasury, TREASURY_BALANCE);

  });

  it("Hacker tries to withdraw fees from treasury!", async () => {

    const hacker = Keypair.generate();
    await airdrop(provider.connection, hacker.publicKey, HACKER_INITIAL_BALANCE);

    // x x x x x x x x x x x x x x x x x x x x x
    // | | | | | | | | | | | | | | | | | | | | |
    //           ADD YOUR CODE BELOW
    // | | | | | | | | | | | | | | | | | | | | |
    // v v v v v v v v v v v v v v v v v v v v v



    // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
    // | | | | | | | | | | | | | | | | | | | | |
    //           ADD YOUR CODE ABOVE
    // | | | | | | | | | | | | | | | | | | | | |
    // x x x x x x x x x x x x x x x x x x x x x
  });


  it("Bug evaluation", async () => {
    exploitSuccessful = false;

    await new Promise(f => setTimeout(f, 400));

    let collected_fees = (await program.account.treasuryLog.fetch(treasury)).collectedFees;

    if (collected_fees.toNumber() === 0) {
      exploitSuccessful = true;
    }
    else {
      assert.fail("You did not succeed to hack the program! Hacker was not able to withdraw fees from the protocol!");
    }

  });

  after("Evaluation", async () => {
    if (exploitSuccessful) {
      console.log('\n\n\x1b[32m', 'CONGRATULATIONS!!!\nYou succeeded to steal the fees from the protocol!', '\x1b[0m')
    }
    else {
      console.log('\n\n\x1b[31m', 'You did not suceed to exploit the program!', '\x1b[0m')
    }

  });
});


async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}
