// The exploit-3 program enables vesting of SPL tokens (progressively release total amount to the final recipient).
// The program is in principle the same as in exploit-2, only adapted to vest SPL tokens.

// TASK: Modify the code indicated below and try to steal tokens from another recipient.
//       Try to exploit the bug found in the exploit-2 program (exploit-3 programs has the same bug).
//       Suppose that a hacker finds vesting to another recipient being in progress and will withdraw his tokens.
//       In the same time, the hacker must take a profit from the hack (his balance after the hack must be greater than before the hack)
//    -> Verify if you were successful by runnig:
//      - `anchor run exploit3`
//      from the terminal

import * as anchor from "@coral-xyz/anchor";
import * as splToken from "@solana/spl-token";
import * as web3 from "@solana/web3.js";
import { assert } from "chai";
import { Exploit3 } from "../../target/types/exploit_3";

describe("Exploit 3", async () => {
  let provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);
  let exploitSuccessful = false;

  const program = anchor.workspace.Exploit3 as anchor.Program<Exploit3>;
  const payer = web3.Keypair.generate();
  const sender = web3.Keypair.generate();
  const recipient = web3.Keypair.generate();
  const hacker = web3.Keypair.generate();
  const escrow = web3.Keypair.generate();
  let mint, senderTokenAccount, recipientTokenAccount, hackerTokenAccount, escrowTokenAccount, escrowPdaAuthority;
  const INITIAL_TOKENS_BALANCE = 1000000000;

  before("Setup", async () => {
    await airdrop(provider.connection, payer.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);
    await airdrop(provider.connection, sender.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);
    await airdrop(provider.connection, recipient.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);
    await airdrop(provider.connection, hacker.publicKey, 10 * anchor.web3.LAMPORTS_PER_SOL);

    [escrowPdaAuthority] = anchor.web3.PublicKey.findProgramAddressSync([anchor.utils.bytes.utf8.encode("ESCROW_PDA_AUTHORITY")], program.programId);

    mint = await splToken.createMint(
      provider.connection,
      payer,
      payer.publicKey,
      null,
      9,
    );

    senderTokenAccount = await splToken.createAccount(provider.connection, sender, mint, sender.publicKey);
    recipientTokenAccount = await splToken.createAccount(provider.connection, recipient, mint, recipient.publicKey);
    hackerTokenAccount = await splToken.createAccount(provider.connection, hacker, mint, hacker.publicKey);
    escrowTokenAccount = await splToken.createAccount(provider.connection, sender, mint, sender.publicKey, anchor.web3.Keypair.generate());

    // Mint tokens to sender's token account
    await splToken.mintTo(
      provider.connection,
      payer,
      mint,
      senderTokenAccount,
      payer,
      INITIAL_TOKENS_BALANCE
    );

    // Mint tokens to hacker's token account
    await splToken.mintTo(
      provider.connection,
      payer,
      mint,
      hackerTokenAccount,
      payer,
      INITIAL_TOKENS_BALANCE
    );
  });


  let now = new anchor.BN(+new Date() / 1000); // current time in seconds
  const amount = new anchor.BN(2001000); // amount to vest
  const start = now.subn(10000); // start vesting in the past so that we do not need to wait
  const end = now; // end now so that we do not need to wait to withdraw whole vested amount
  const interval = new anchor.BN(5); // unlock new amount every X seconds

  it("Initialize vesting!", async () => {
    const tx = await program.methods
      .initVesting(recipient.publicKey, amount, start, end, interval)
      .accounts({
        sender: sender.publicKey,
        senderTokenAccount: senderTokenAccount,
        escrow: escrow.publicKey,
        escrowTokenAccount: escrowTokenAccount,
        mint: mint,
        tokenProgram: splToken.TOKEN_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
      })
      .signers([sender, escrow])
      .rpc();
  });

  it("Hacker tries to steal tokens!", async () => {

    // Please use these accounts so that the hack evaluation works correctly
    hackerTokenAccount;
    hacker;
    const escrowTokenAccountHacker = await splToken.createAccount(provider.connection, hacker, mint, hacker.publicKey, anchor.web3.Keypair.generate());
    const escrowHacker = anchor.web3.Keypair.generate();

    // x x x x x x x x x x x x x x x x x x x x x
    // | | | | | | | | | | | | | | | | | | | | |
    //           EDIT THE CODE BELOW
    // | | | | | | | | | | | | | | | | | | | | |
    // v v v v v v v v v v v v v v v v v v v v v






    // ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
    // | | | | | | | | | | | | | | | | | | | | |
    //           EDIT THE CODE ABOVE
    // | | | | | | | | | | | | | | | | | | | | |
    // x x x x x x x x x x x x x x x x x x x x x
  });


  it("Bug evaluation", async () => {
    exploitSuccessful = false;

    let now = new anchor.BN(+new Date() / 1000);
    let maxFutureDuration = 10;

    if (now < end) {
      if (end.sub(now).toNumber() > maxFutureDuration) {
        assert.fail(`Vesting cannot end more than ${maxFutureDuration} seconds in the future to prevent long bug evaluation waiting times! Please modify your vesting settings!!`);
      }
      await countDown(end.sub(now).toNumber(), 1);
    }

    try {
      await program.methods.withdrawUnlocked()
        .accounts(
          {
            recipient: recipient.publicKey,
            recipientTokenAccount: recipientTokenAccount,
            escrow: escrow.publicKey,
            escrowTokenAccount: escrowTokenAccount,
            escrowPdaAuthority: escrowPdaAuthority,
            mint: mint,
            tokenProgram: splToken.TOKEN_PROGRAM_ID,
            systemProgram: web3.SystemProgram.programId,
          }
        )
        .signers([recipient])
        .rpc({ commitment: "confirmed" });
      assert.fail("You did not succeed to hack the program! Recipient was able to withdraw the total vested amount!");
    }
    catch (err) {
      let hackerTokenBalance = (await splToken.getAccount(provider.connection, hackerTokenAccount)).amount;
      if (hackerTokenBalance > INITIAL_TOKENS_BALANCE) {
        exploitSuccessful = true;
      }
      else {
        assert.fail("You did not succeed to hack the program! Hacker was not able to withdraw more than his initial deposit!");
      }
    }

  });

  after("Evaluation", async () => {
    if (exploitSuccessful) {
      console.log('\n\n\x1b[32m', 'CONGRATULATIONS!!!\nYou succeeded to steal funds from someone else!', '\x1b[0m')
    }
    else {
      console.log('\n\n\x1b[31m', 'You did not suceed to exploit the program!', '\x1b[0m')
    }

  });
});


async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(await connection.requestAirdrop(address, amount), "confirmed");
}

async function sleep(seconds) {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
}

async function countDown(duration, update) {
  if (duration < update) {
    await sleep(duration);
  }
  else {
    let iters = Math.ceil(duration / update);
    let elapsed = 0;
    for (let i = 0; i < iters; i++) {
      process.stdout.write("Waiting " + (duration - elapsed) + " seconds until the vesting expires...")
      await sleep(update);
      elapsed = elapsed + update;
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
    }

  }
}
