// This program enables vesting (progressively release total amount to the final recipient).
// The init_vesting instruction takes as parameters the total amount to be vested,
// the start and end times, when the vesting should be active and an interval how often a
// new partial amount will be released to the recipient. The recipient can withdraw
// currently unlocked funds in multiple transactions or the complete amount once the vesting has expired.

// TASK: Modify the ./expoit-pocs/exploit-2/exploit-2.ts file and try to find bugs in the vesting program.
//       There are multiple issues in the calculation of the unlocked amount. To finish this task, find a
//       bug that will not allow the recipient to withdraw the total vested amount even after the vesting has expired.
//    -> Verify if you were successful by runnig:
//      - `anchor run exploit2`
//      from the terminal

use anchor_lang::prelude::*;
use anchor_lang::system_program::{transfer, Transfer};

declare_id!("8NKomCZJRrSjEyWkrHR6LouYW79nvnXUcgmP4ADBnW8C");

#[program]
pub mod exploit_2 {
    use super::*;

    pub fn init_vesting(
        ctx: Context<InitVesting>,
        amount: u64,
        start_at: u64,
        end_at: u64,
        interval: u64,
    ) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;
        require!(amount > 0, VestingError::InvalidAmount);
        // Validate timestamps order (overflow check)
        require!(end_at > start_at, VestingError::InvalidTimeRange);
        // Validate interval
        require!(end_at - start_at > interval, VestingError::InvalidInterval);
        require!(interval > 0, VestingError::InvalidInterval);

        escrow.amount = amount;
        escrow.start_time = start_at;
        escrow.end_time = end_at;
        escrow.interval = interval;
        escrow.recipient = ctx.accounts.recipient.key();

        transfer(
            CpiContext::new(
                ctx.accounts.system_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.sender.to_account_info(),
                    to: escrow.to_account_info(),
                },
            ),
            amount,
        )?;

        Ok(())
    }

    pub fn withdraw_unlocked(ctx: Context<WithdrawUnlocked>) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;
        let recipient = &mut ctx.accounts.recipient;

        let current_time = Clock::get()?.unix_timestamp as u64;
        let unlocked_amount = escrow
            .amount_unlocked(current_time)
            .ok_or(VestingError::InvalidAmount)?;

        **escrow.to_account_info().lamports.borrow_mut() = escrow
            .to_account_info()
            .lamports()
            .checked_sub(unlocked_amount)
            .ok_or(VestingError::Underflow)?;

        **recipient.lamports.borrow_mut() = recipient
            .lamports()
            .checked_add(unlocked_amount)
            .ok_or(VestingError::Overflow)?;

        escrow.withdrawal += unlocked_amount;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitVesting<'info> {
    #[account(mut)]
    pub sender: Signer<'info>,

    /// CHECK: arbitrary account
    pub recipient: AccountInfo<'info>,

    #[account(
        init,
        payer = sender,
        space = 8 + 32 + 5*8,
     )]
    pub escrow: Account<'info, Escrow>,

    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WithdrawUnlocked<'info> {
    #[account(mut)]
    pub recipient: Signer<'info>,

    #[account(
        mut,
        has_one = recipient
    )]
    pub escrow: Account<'info, Escrow>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Escrow {
    pub recipient: Pubkey,
    pub amount: u64,
    pub withdrawal: u64,
    pub start_time: u64,
    pub end_time: u64,
    pub interval: u64,
}

#[error_code]
pub enum VestingError {
    InvalidAmount,
    InvalidTimeRange,
    InvalidInterval,
    Overflow,
    Underflow,
}

impl Escrow {
    pub fn amount_unlocked(&self, now: u64) -> Option<u64> {
        // take minimum from now and end time
        let time = if now < self.end_time {
            now
        } else {
            self.end_time
        };

        // end_at - start_at, difference of timestamps in second
        let duration = self.end_time.checked_sub(self.start_time)?;

        // amount * interval / duration
        let interval_amount = self
            .amount
            .checked_mul(self.interval)?
            .checked_div(duration)?;

        // (time - self.start_at) / self.interval + 1, current and passed intervals are unlocked
        let nr_intervals = time
            .checked_sub(self.start_time)?
            .checked_div(self.interval)?
            .checked_add(1)?;

        // nr_intervals * interval_amount - self.withdrawal
        nr_intervals
            .checked_mul(interval_amount)?
            .checked_sub(self.withdrawal)
    }
}
