// This program enables vesting of SPL tokens (progressively release total amount to the final recipient).
// The program is in principle the same as in exploit-2, only adapted to vest SPL tokens.

// TASK: Modify the ./expoit-pocs/exploit-3/exploit-3.ts file and try to steal tokens from another recipient.
//       Try to exploit the bug found in the exploit-2 program (exploit-3 programs has the same bug).
//       Suppose that a hacker finds vesting to another recipient being in progress and will withdraw his tokens.
//       In the same time, the hacker must take a profit from the hack (his balance after the hack must be greater than before the hack)
//    -> Verify if you were successful by runnig:
//      - `anchor run exploit3`
//      from the terminal

use anchor_lang::prelude::*;
use anchor_spl::token::spl_token::instruction::AuthorityType;
use anchor_spl::token::{
    set_authority, transfer, Mint, SetAuthority, Token, TokenAccount, Transfer,
};

declare_id!("GbgJnHbjmXZy9HpsVXogzSugTdpW6mcvfYEXWabkDicC");

#[program]
pub mod exploit_3 {
    use super::*;

    pub fn init_vesting(
        ctx: Context<InitVesting>,
        recipient: Pubkey,
        amount: u64,
        start_at: u64,
        end_at: u64,
        interval: u64,
    ) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;
        require!(amount > 0, VestingError::InvalidAmount);
        // Validate timestamps order (overflow check)
        require!(end_at > start_at, VestingError::InvalidTimeRange);
        // Validate interval
        require!(end_at - start_at > interval, VestingError::InvalidInterval);
        require!(interval > 0, VestingError::InvalidInterval);

        escrow.amount = amount;
        escrow.start_time = start_at;
        escrow.end_time = end_at;
        escrow.interval = interval;
        escrow.recipient = recipient;

        let (escrow_pda_authority, _) =
            Pubkey::find_program_address(&[b"ESCROW_PDA_AUTHORITY"], ctx.program_id);

        // Set escrow's token account authority to the program's PDA
        set_authority(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                SetAuthority {
                    account_or_mint: ctx.accounts.escrow_token_account.to_account_info(),
                    current_authority: ctx.accounts.sender.to_account_info(),
                },
            ),
            AuthorityType::AccountOwner,
            Some(escrow_pda_authority),
        )?;

        // Transfer tokens from sender's token account to escrow's token account
        transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.sender_token_account.to_account_info(),
                    to: ctx.accounts.escrow_token_account.to_account_info(),
                    authority: ctx.accounts.sender.to_account_info(),
                },
            ),
            amount,
        )?;

        Ok(())
    }

    pub fn withdraw_unlocked(ctx: Context<WithdrawUnlocked>) -> Result<()> {
        let escrow = &mut ctx.accounts.escrow;

        let current_time = Clock::get()?.unix_timestamp as u64;
        let unlocked_amount = escrow
            .amount_unlocked(current_time)
            .ok_or(VestingError::InvalidAmount)?;

        let seeds = &[
            b"ESCROW_PDA_AUTHORITY".as_ref(),
            &[*ctx.bumps.get("escrow_pda_authority").unwrap()],
        ];
        transfer(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                Transfer {
                    from: ctx.accounts.escrow_token_account.to_account_info(),
                    to: ctx.accounts.recipient_token_account.to_account_info(),
                    authority: ctx.accounts.escrow_pda_authority.to_account_info(),
                },
            )
            .with_signer(&[&seeds[..]]),
            unlocked_amount,
        )?;

        escrow.withdrawal += unlocked_amount;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct InitVesting<'info> {
    #[account(mut)]
    pub sender: Signer<'info>,

    #[account(mut,
        token::authority = sender,
        token::mint = mint
    )]
    pub sender_token_account: Account<'info, TokenAccount>,

    #[account(
        init,
        payer = sender,
        space = 8 + 32 + 5*8,
     )]
    pub escrow: Account<'info, Escrow>,

    #[account(
        mut,
        token::mint = mint
        // token account authority will be transfered to program PDA during instruction execution
    )]
    pub escrow_token_account: Account<'info, TokenAccount>,

    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WithdrawUnlocked<'info> {
    #[account(mut)]
    pub recipient: Signer<'info>,

    #[account(mut,
        token::mint = mint,
        token::authority = recipient
    )]
    pub recipient_token_account: Account<'info, TokenAccount>,

    #[account(
        mut,
        has_one = recipient
    )]
    pub escrow: Account<'info, Escrow>,

    #[account(
        mut,
        token::mint = mint,
        token::authority = escrow_pda_authority  // only the program has the authority as this is a PDA
    )]
    pub escrow_token_account: Account<'info, TokenAccount>,

    /// CHECK: we do not read or write to this account
    #[account(
        seeds = [b"ESCROW_PDA_AUTHORITY"],
        bump
    )]
    pub escrow_pda_authority: AccountInfo<'info>,

    pub mint: Account<'info, Mint>,
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct Escrow {
    pub recipient: Pubkey,
    pub amount: u64,
    pub withdrawal: u64,
    pub start_time: u64,
    pub end_time: u64,
    pub interval: u64,
}

#[error_code]
pub enum VestingError {
    InvalidAmount,
    InvalidTimeRange,
    InvalidInterval,
    Overflow,
    Underflow,
}

impl Escrow {
    pub fn amount_unlocked(&self, now: u64) -> Option<u64> {
        // minimum from now and end time
        let time = if now < self.end_time {
            now
        } else {
            self.end_time
        };

        // end_at - start_at, difference of timestamps in second
        let duration = self.end_time.checked_sub(self.start_time)?;

        // amount * interval / duration
        let interval_amount = self
            .amount
            .checked_mul(self.interval)?
            .checked_div(duration)?;

        // (time - self.start_at) / self.interval + 1, current and passed intervals are unlocked
        let nr_intervals = time
            .checked_sub(self.start_time)?
            .checked_div(self.interval)?
            .checked_add(1)?;

        // nr_intervals * interval_amount - self.withdrawal
        nr_intervals
            .checked_mul(interval_amount)?
            .checked_sub(self.withdrawal)
    }
}
